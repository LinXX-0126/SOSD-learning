# 1. 多线程

## 1.1 基本概念：程序、进程、线程

- ***程序(program)***：

  为完成特定任务，用某种语言编写的一组指令的集合

  即：一段**静态的**代码，静态对象

- ***进程(process)***：

  程序的一次执行过程，或是正在运行的一个程序

  是一个**动态的**过程，有它自身的产生、存在和消亡的过程，即生命周期

- ***线程(thread)***：

  进程可进一步细化为进程，是一个程序内部的一条执行路径

  - 若一个进程同时间**并行**执行多个线程，就是支持多线程的

  - 线程作为调度和执行的单位，**每个线程拥有独立的运行栈和程序计数器(pc)**，线程切换的开销小

  - 一个进程的多个线程共享相同的内存单元/内存地址空间，他们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效，但多个线程操作共享的系统资源可能会带来<u>安全的隐患</u>
  
- ***单核CPU与多核CPU***

  - 单核CPU其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务
  - 多核更能发挥多线程的效率
  - 一个Java应用程序java.exe，至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程
  - 如果发生异常，会影响主线程

- ***并行与并发***

  - 并行：多个CPU同时执行多个任务
  - 并发：一个CPU同时执行多个任务

### 多线程的优点

- 提高应用程序的响应，对图形化界面更有意义，可增强用户体验
- 提高计算机CPU的利用率
- 改善程序结构，将既长又复杂的进程分为多个线程，独立运行，利于理解和修改

### 何时需要多线程

- 程序需要同时执行两个或多个任务
- 程序需要实现一些需要等待的任务时，汝用户输入、文件读写操作、网络操作、搜索等
- 需要后台运行的程序

## 1.2 线程的创建和使用

- Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现
- Thread类的特性
  - 每个线程都通过某个特定的Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体
  - 通过该Thread对象的start()方法来启用这个线程，而非直接调用run()

---

### 1.2.1 多线程的创建

方式一：

- 创建一个继承于Thread类的子类

 * 重写Thread类的run()方法 -->将此线程执行的操作声明在run()中
 * 创建Thread类的子类对象
 * 通过此对象调用start()

---

方式二：

​	创建Thread类的匿名子类的方式

```java
new Thread(){
    //重写run()
}.start();
```

---

**PS:**

- 问题一：

  我们不能通过直接调用run()启动线程

- 问题二：

  不可以让已经start()的线程再次start()，会报IllegalThread

### 1.2.2 线程的常用方法

- **void start():**启动线程，并执行对象的run()方法

- **run():**线程在被调度时执行的操作

- **String getName():**返回线程的名称

- **void setName(Sring name):**设置该线程名称

- **static Thread currentThread():**

  返回当前线程，在Thread子类中就是this，通常用于主线程和Runnable实现类

- **static void yield():**

  线程让步

  暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程

  若队伍中没有同优先级的线程，忽略此方法

- **join():**

  当某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到join()方法加入的join线程执行完为之

- **static void sleep(long millis):**x

  指定时间：毫秒

  令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重新排队

- **stop():**强制线程生命期结束
- **boolean isAlive():**判断线程是否还活着

### 1.2.3 线程优先级的设置



## 1.3 线程的生命周期

### 线程的几种状态

- 新建

  当一个Thread类或其子类的对象被声明或创建时，新生的线程对象处于新建状态

  调用**start()**

- 就绪

  处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已经具备了运行条件，只是没分配到CPU资源

- 运行

  当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能

  执行**run()**

  **失去CPU资源执行权或yield()**，返回就绪状态

- 阻塞

  在某种特殊情况下，被认为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态

- 死亡

  线程完成了它的全部工作或线程被提前强制地中止或出现异常导致结束

